#### [621. 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)

难度中等256

给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。

然而，两个**相同种类**的任务之间必须有长度为 **n** 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的**最短时间**。

 

**示例 ：**

```
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B.
     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 
```

 

**提示：**

1. 任务的总个数为 `[1, 10000]`。
2. `n` 的取值范围为 `[0, 100]`。

## 思路

```
这里采用贪心算法思路：
比如 给定的 任务[A:3, B:2, C:1] n = 2
那么可以 A->B->C  ->A->B->(等待)->A :结果 time：7
如果使用 A->B->(等待)->A 所以 可以进行按轮次安排任务， 也即是 每轮 是 n+1 个任务。 不够的话就进入空闲等待了。

比如这样[A:4,B:2,C:2,D:1,E:1] n = 2, 那么按上面的来 每轮安排 n+1 个任务 也就是 3 个任务
第一轮： A->B->C  走完之后的情况：[A:3,B:1,D:1,E:1]
第二轮： A->B->D  走完之后的情况：[A:2,E:1]
第三轮： A->E->(等待)  走完之后的情况：[A:1]
第四轮： A        走完之后的情况：[]
总共时间：10

```

## 代码

```java
import java.util.*;
class Solution {
    public int leastInterval(char[] tasks, int n) {
        // 这题带给我的理解 就是 很多时候不用去记录 比如 ABC 不用记录 ABC 给他们排序保存， 只需要 用过 或者使用 计数器这些东西足够
        /*
            [A,A,A,A,B,B,C]  -> [A:3, B:2,C:1] -> [0.....,1,2,3]  n=2 的情况，然后使用每次的 n + 1 个任务 比如 A B C 这时候再执行 A 正好不需要冷却。 如果是 A B （等待） A 就需要冷却
        */
        int [] map = new int[26];
        // 将 task 字符转入 map 中存储
        for(char c:tasks)
            map[c - 'A']++;   // 转换使用数字存储 
        // 然后定义一个数字 记录全局时间。
        int time = 0;
        Arrays.sort(map);  // 排序 [0.....1,2,3]

        while(map[25] > 0){
            int i = 0; // 记录 n 的轮次 是否满足了
            while(i<=n){ // 这里 要 <= n 这样 才能 n+1 轮次 
                // 首先要判断下 最大轮次是否已经走完
                if(map[25] == 0)
                    break;
                if(i < 26 && map[25 - i] > 0 )
                    map[25 - i]--;  // 走轮次
                time++;
                i++;
            }
            Arrays.sort(map);  // 再重新排序 看是否最大的已经走完 [A:3,B:3,C:2]  A 可能会先走完
        }

         return time;
    }
}
```

