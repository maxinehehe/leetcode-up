#### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

难度中等572

给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例:**

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

**说明:**

- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
- 你算法的时间复杂度应该为 O(*n2*) 。

**进阶:** 你能将算法的时间复杂度降低到 O(*n* log *n*) 吗?

## 考虑 使用二维数组

### 思路

```
dp[i] 表示 i 之前的元素的 最大连续上升序列数
因为一次往前走 无法判断所有的情况， 比如 [10,9,2,5,3,7,101,18]
走到 3 时候， 考虑的不仅仅是 5 还有 5 之前的事情， 比如后面 出现 个 2 ，还要考虑 2 的事情， 所以每往后走一次考虑的事情都不一样。

```

### 代码

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        return useDP(nums);
       
    }
    public int useDP(int[] nums){
        int n = nums.length ;
        if(n==0) return 0;
        int [] dp = new int[n];
        dp[0] = 1;
        int maxV = 0;
        // 比我大的我不放在眼里 我只看比我小的 然后 取它 最大连续子序列
        int maxLast = 1;
        for(int i = 1; i<n; i++){
            int maxv = 0;
            for(int j = 0; j < i; j++){
                if(nums[i] > nums[j]){
                    // 只看到比自己小的 然后 进行取路径中 最大的值  
                    // 这样考虑 是防止这样的序列 2 5 3 2   当 第二个 2 位置的时候 就不好说了
                    maxv = Math.max(maxv, dp[j]);
                }
            }
            // dp[i] 找到比他小一点的
            dp[i] = maxv + 1; // 如果 一次if也进不去 那么他就只有一个长度 即他自己本身
            // 标记最大值
            maxLast = Math.max(dp[i], maxLast);
        }
        return maxLast;
    }
}
```



```
10 9 2 5 3 7 2 101 18
 1 1 1 2 2 3 
这里 到 第二个 2 的时候需要注意： 它是不会和 前面的 5 3 7大的， 所以不会进入他们的逻辑， 所以没有比他小的，他的 最大连续上升子序列即dp[6] 为 1 
对于 101 dp[7] 当他比较到 2(dp[6]) 的时候， 它比2大 但此时2 的dp[6] == 1
所以会取比较大的 dp[5] == 3 的 值， 所以需要一个局部最大值记录。 还需要一个整体最大值记录。
```

